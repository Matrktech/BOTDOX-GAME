<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dots and Boxes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');
        body {
            font-family: 'Roboto Mono', monospace;
            background-color: #1a1a2e;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 2rem;
            box-sizing: border-box;
            user-select: none;
            touch-action: none;
        }
        .game-wrapper {
            background-color: #2e1a3e;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: #d8b8ff;
        }
        canvas {
            border: 4px solid #a464ff;
            background-color: #0d0d1b;
            border-radius: 0.5rem;
            touch-action: none;
        }
        .game-status {
            margin-top: 1rem;
            font-size: 1rem;
            font-weight: 700;
        }
        .score-board {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 1rem;
            gap: 0.5rem;
            align-items: center;
        }
        .player-card {
            background-color: #4a286c;
            padding: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 2px solid transparent;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            justify-content: center;
        }
        .player-card.active {
            border-color: #f7a421;
            box-shadow: 0 0 10px #f7a421;
        }
        .player-name {
            font-size: 0.875rem;
            font-weight: 700;
            white-space: nowrap;
        }
        .score {
            font-size: 1.25rem;
            font-weight: 700;
        }
        .button-container {
            margin-top: 1rem;
        }
        .btn {
            background-color: #8c24b1;
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 700;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .btn:hover {
            background-color: #6a1a8c;
            transform: scale(1.05);
        }
        #messageBox {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2e1a3e;
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            text-align: center;
        }
        #messageBox h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }
        .mode-selection {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            padding: 2rem;
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <h1 id="title">Dots and Boxes</h1>
        <div id="startScreen">
            <div class="mode-selection">
                <button id="twoPlayerBtn" class="btn">Two Players</button>
                <button id="vsComputerBtn" class="btn">Vs. Computer</button>
            </div>
        </div>
        <canvas id="gameCanvas" style="display:none;"></canvas>
        <div id="gameUI" style="display:none;">
            <div class="score-board">
                <div id="player1Card" class="player-card active">
                    <div class="player-name">Player 1</div>
                    <div id="score1" class="score">0</div>
                </div>
                <p id="gameStatus" class="game-status">Current Turn: Player 1</p>
                <div id="player2Card" class="player-card">
                    <div class="player-name">Player 2</div>
                    <div id="score2" class="score">0</div>
                </div>
            </div>
            <div class="button-container">
                <button id="restartBtn" class="btn">Restart</button>
            </div>
        </div>
    </div>
    <div id="messageBox">
        <h2 id="messageTitle">Game Over!</h2>
        <button id="restartMessageBtn" class="btn mt-4">Play Again</button>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const gameUI = document.getElementById('gameUI');
            const statusEl = document.getElementById('gameStatus');
            const restartBtn = document.getElementById('restartBtn');
            const messageBox = document.getElementById('messageBox');
            const messageTitle = document.getElementById('messageTitle');
            const restartMessageBtn = document.getElementById('restartMessageBtn');
            const player1Card = document.getElementById('player1Card');
            const player2Card = document.getElementById('player2Card');
            const score1El = document.getElementById('score1');
            const score2El = document.getElementById('score2');
            const twoPlayerBtn = document.getElementById('twoPlayerBtn');
            const vsComputerBtn = document.getElementById('vsComputerBtn');
            const startScreen = document.getElementById('startScreen');
            const titleEl = document.getElementById('title');

            const boardSize = 6;
            let padding = 25;
            let dotRadius = 5;
            let cellSize = 50;
            let lineWidth = 3;

            let lines = [];
            let boxes = [];
            let scores = { 'player1': 0, 'player2': 0 };
            let currentPlayer = 'player1';
            let vsComputer = false;

            const playerColors = {
                'player1': { line: '#f7a421', box: 'rgba(247, 164, 33, 0.4)' },
                'player2': { line: '#a464ff', box: 'rgba(164, 100, 255, 0.4)' }
            };

            const resizeCanvas = () => {
                const gameWrapper = document.querySelector('.game-wrapper');
                const availableSize = Math.min(window.innerWidth, window.innerHeight) * 0.75;
                cellSize = Math.floor(availableSize / (boardSize + 1));
                padding = cellSize * 0.4;
                dotRadius = cellSize * 0.15;
                lineWidth = cellSize * 0.1;

                canvas.width = (boardSize * cellSize) + (2 * padding);
                canvas.height = (boardSize * cellSize) + (2 * padding);
                drawGrid();
            };

            window.addEventListener('resize', resizeCanvas);

            const switchTurn = (scored) => {
                if (!scored) {
                    currentPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
                    player1Card.classList.toggle('active', currentPlayer === 'player1');
                    player2Card.classList.toggle('active', currentPlayer === 'player2');
                    statusEl.textContent = `Current Turn: ${currentPlayer === 'player1' ? (vsComputer ? 'You' : 'Player 1') : (vsComputer ? 'Computer' : 'Player 2')}`;

                    if (vsComputer && currentPlayer === 'player2') {
                        setTimeout(computerMove, 500);
                    }
                }
            };

            const updateStatus = () => {
                score1El.textContent = scores['player1'];
                score2El.textContent = scores['player2'];

                if (boxes.length === boardSize * boardSize) {
                    let winnerText = "It's a tie!";
                    if (scores['player1'] > scores['player2']) {
                        winnerText = `${vsComputer ? 'You' : 'Player 1'} win!`;
                    } else if (scores['player2'] > scores['player1']) {
                        winnerText = `${vsComputer ? 'The computer' : 'Player 2'} wins!`;
                    }
                    messageTitle.textContent = `Game Over! ${winnerText}`;
                    messageBox.style.display = 'block';
                }
            };

            const drawGrid = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineCap = 'round';
                ctx.lineWidth = lineWidth;

                boxes.forEach(box => {
                    ctx.fillStyle = box.color;
                    const x = padding + box.x * cellSize + dotRadius;
                    const y = padding + box.y * cellSize + dotRadius;
                    ctx.fillRect(x, y, cellSize - 2 * dotRadius, cellSize - 2 * dotRadius);
                });

                lines.forEach(line => {
                    ctx.strokeStyle = line.color;
                    ctx.beginPath();
                    ctx.moveTo(padding + line.x1 * cellSize, padding + line.y1 * cellSize);
                    ctx.lineTo(padding + line.x2 * cellSize, padding + line.y2 * cellSize);
                    ctx.stroke();
                });

                ctx.fillStyle = '#ff8c42';
                for (let i = 0; i < boardSize + 1; i++) {
                    for (let j = 0; j < boardSize + 1; j++) {
                        ctx.beginPath();
                        ctx.arc(padding + i * cellSize, padding + j * cellSize, dotRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            };

            const findLine = (x1, y1, x2, y2) => {
                if (x1 > x2 || y1 > y2) {
                    [x1, x2] = [x2, x1];
                    [y1, y2] = [y2, y1];
                }
                return lines.find(line => 
                    line.x1 === x1 && line.y1 === y1 && line.x2 === x2 && line.y2 === y1
                );
            };

            const checkForCompletedBox = (x, y, isVertical) => {
                let newBoxesCount = 0;
                let potentialBoxes = [];

                if (isVertical) {
                    potentialBoxes.push({ x: x - 1, y: y });
                    potentialBoxes.push({ x: x, y: y });
                } else {
                    potentialBoxes.push({ x: x, y: y - 1 });
                    potentialBoxes.push({ x: x, y: y });
                }

                potentialBoxes.forEach(box => {
                    if (box.x >= 0 && box.x < boardSize && box.y >= 0 && box.y < boardSize) {
                        const top = findLine(box.x, box.y, box.x + 1, box.y);
                        const right = findLine(box.x + 1, box.y, box.x + 1, box.y + 1);
                        const bottom = findLine(box.x, box.y + 1, box.x + 1, box.y + 1);
                        const left = findLine(box.x, box.y, box.x, box.y + 1);

                        const isCompleted = [top, right, bottom, left].every(line => line !== undefined);

                        if (isCompleted && !boxes.some(b => b.x === box.x && b.y === box.y)) {
                            boxes.push({ x: box.x, y: box.y, color: playerColors[currentPlayer].box });
                            newBoxesCount++;
                        }
                    }
                });
                return newBoxesCount;
            };

            const handleTurn = (x1, y1, x2, y2) => {
                if (x1 > x2 || y1 > y2) {
                    [x1, x2] = [x2, x1];
                    [y1, y2] = [y2, y1];
                }

                if (findLine(x1, y1, x2, y2)) {
                    return;
                }

                lines.push({ x1, y1, x2, y2, color: playerColors[currentPlayer].line });
                const newBoxes = checkForCompletedBox(Math.min(x1, x2), Math.min(y1, y2), x1 === x2);
                scores[currentPlayer] += newBoxes;
                
                drawGrid();
                updateStatus();
                switchTurn(newBoxes > 0);
            };

            const handleInput = (event) => {
                if (currentPlayer === 'player2' && vsComputer) {
                    return;
                }

                const rect = canvas.getBoundingClientRect();
                let mouseX, mouseY;

                if (event.type.startsWith('touch')) {
                    const touch = event.touches[0];
                    mouseX = touch.clientX - rect.left;
                    mouseY = touch.clientY - rect.top;
                    event.preventDefault();
                } else {
                    mouseX = event.clientX - rect.left;
                    mouseY = event.clientY - rect.top;
                }
                
                const gridX = Math.round((mouseX - padding) / cellSize);
                const gridY = Math.round((mouseY - padding) / cellSize);

                const dx = Math.abs(mouseX - (padding + gridX * cellSize));
                const dy = Math.abs(mouseY - (padding + gridY * cellSize));

                let x1, y1, x2, y2;

                if (dx < cellSize / 4 && dy > cellSize / 4) {
                    if (gridY >= 0 && gridY < boardSize && gridX >= 0 && gridX < boardSize + 1) {
                        x1 = x2 = gridX;
                        y1 = gridY;
                        y2 = gridY + 1;
                    } else { return; }
                } else if (dy < cellSize / 4 && dx > cellSize / 4) {
                    if (gridX >= 0 && gridX < boardSize && gridY >= 0 && gridY < boardSize + 1) {
                        x1 = gridX;
                        x2 = gridX + 1;
                        y1 = y2 = gridY;
                    } else { return; }
                } else { return; }
                
                handleTurn(x1, y1, x2, y2);
            };

            const computerMove = () => {
                const availableMoves = [];
                for (let i = 0; i <= boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (!findLine(i, j, i, j + 1)) {
                            availableMoves.push({ x1: i, y1: j, x2: i, y2: j + 1, isVertical: true });
                        }
                    }
                }
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j <= boardSize; j++) {
                        if (!findLine(i, j, i + 1, j)) {
                            availableMoves.push({ x1: i, y1: j, x2: i + 1, y2: j, isVertical: false });
                        }
                    }
                }

                // Simple computer logic: prioritize completing a box
                for (const move of availableMoves) {
                    const tempLines = [...lines, { ...move, color: 'temp' }];
                    const isVertical = move.isVertical;
                    let newBoxes = 0;
                    
                    const potentialBoxes = isVertical ? [{ x: move.x1 - 1, y: move.y1 }, { x: move.x1, y: move.y1 }] : [{ x: move.x1, y: move.y1 - 1 }, { x: move.x1, y: move.y1 }];
                    
                    potentialBoxes.forEach(box => {
                        if (box.x >= 0 && box.x < boardSize && box.y >= 0 && box.y < boardSize) {
                             const top = tempLines.find(l => l.x1 === box.x && l.y1 === box.y && l.x2 === box.x + 1 && l.y2 === box.y);
                             const right = tempLines.find(l => l.x1 === box.x + 1 && l.y1 === box.y && l.x2 === box.x + 1 && l.y2 === box.y + 1);
                             const bottom = tempLines.find(l => l.x1 === box.x && l.y1 === box.y + 1 && l.x2 === box.x + 1 && l.y2 === box.y + 1);
                             const left = tempLines.find(l => l.x1 === box.x && l.y1 === box.y && l.x2 === box.x && l.y2 === box.y + 1);

                             if (top && right && bottom && left && !boxes.some(b => b.x === box.x && b.y === box.y)) {
                                 newBoxes++;
                             }
                        }
                    });

                    if (newBoxes > 0) {
                        handleTurn(move.x1, move.y1, move.x2, move.y2);
                        return;
                    }
                }
                
                // If no box can be completed, make a random move
                if (availableMoves.length > 0) {
                    const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                    handleTurn(randomMove.x1, randomMove.y1, randomMove.x2, randomMove.y2);
                }
            };

            const initializeGame = (mode) => {
                vsComputer = mode === 'vs-computer';
                lines = [];
                boxes = [];
                scores = { 'player1': 0, 'player2': 0 };
                currentPlayer = 'player1';
                messageBox.style.display = 'none';
                
                // Hide start screen and show game elements
                startScreen.style.display = 'none';
                titleEl.style.display = 'none';
                canvas.style.display = 'block';
                gameUI.style.display = 'block';

                // Set player names
                document.querySelector('#player1Card .player-name').textContent = vsComputer ? 'You' : 'Player 1';
                document.querySelector('#player2Card .player-name').textContent = vsComputer ? 'Computer' : 'Player 2';
                
                resizeCanvas();
                player1Card.classList.add('active');
                player2Card.classList.remove('active');
                updateStatus();
                statusEl.textContent = `Current Turn: ${vsComputer ? 'You' : 'Player 1'}`;
            };

            const showStartScreen = () => {
                startScreen.style.display = 'block';
                gameUI.style.display = 'none';
                canvas.style.display = 'none';
                messageBox.style.display = 'none';
                titleEl.style.display = 'block';
            };


            twoPlayerBtn.addEventListener('click', () => initializeGame('two-player'));
            vsComputerBtn.addEventListener('click', () => initializeGame('vs-computer'));
            restartBtn.addEventListener('click', () => {
                showStartScreen();
            });
            restartMessageBtn.addEventListener('click', () => {
                initializeGame(vsComputer ? 'vs-computer' : 'two-player');
            });

            canvas.addEventListener('mousedown', handleInput);
            canvas.addEventListener('touchstart', handleInput);
        });
    </script>
</body>
</html>
