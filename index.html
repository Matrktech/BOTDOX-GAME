<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dots and Boxes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');
        body {
            font-family: 'Roboto Mono', monospace;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 2rem;
            box-sizing: border-box;
        }
        .game-wrapper {
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 100%;
        }
        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #a0aec0;
        }
        canvas {
            border: 4px solid #4a5568;
            background-color: #1a202c;
            border-radius: 0.5rem;
            touch-action: none;
        }
        .game-status {
            margin-top: 1.5rem;
            font-size: 1.25rem;
            font-weight: 700;
        }
        .score-board {
            display: flex;
            justify-content: space-around;
            margin-top: 1rem;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .player-card {
            background-color: #4a5568;
            padding: 1rem;
            border-radius: 0.5rem;
            flex: 1;
            min-width: 150px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .player-card.active {
            border: 2px solid #63b3ed;
            box-shadow: 0 0 15px #63b3ed;
        }
        .player-name {
            font-size: 1.125rem;
            font-weight: 700;
        }
        .score {
            font-size: 2rem;
            font-weight: 700;
            margin-top: 0.5rem;
        }
        .button-container {
            margin-top: 1.5rem;
        }
        .btn {
            background-color: #48bb78;
            color: white;
            padding: 0.75rem 2rem;
            font-size: 1rem;
            font-weight: 700;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        .btn:hover {
            background-color: #38a169;
            transform: scale(1.05);
        }
        #messageBox {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #4a5568;
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
            text-align: center;
        }
        #messageBox h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <h1>Dots and Boxes</h1>
        <canvas id="gameCanvas"></canvas>
        <p id="gameStatus" class="game-status">Current Turn: Player 1</p>
        <div class="score-board">
            <div id="player1Card" class="player-card active">
                <div class="player-name">Player 1</div>
                <div id="score1" class="score">0</div>
            </div>
            <div id="player2Card" class="player-card">
                <div class="player-name">Player 2</div>
                <div id="score2" class="score">0</div>
            </div>
        </div>
        <div class="button-container">
            <button id="restartBtn" class="btn">Restart</button>
        </div>
    </div>
    <div id="messageBox">
        <h2 id="messageTitle">Game Over!</h2>
        <button id="restartMessageBtn" class="btn mt-4">Play Again</button>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const statusEl = document.getElementById('gameStatus');
            const restartBtn = document.getElementById('restartBtn');
            const messageBox = document.getElementById('messageBox');
            const messageTitle = document.getElementById('messageTitle');
            const restartMessageBtn = document.getElementById('restartMessageBtn');
            const player1Card = document.getElementById('player1Card');
            const player2Card = document.getElementById('player2Card');
            const score1El = document.getElementById('score1');
            const score2El = document.getElementById('score2');

            const boardSize = 6;
            const cellSize = 50;
            const padding = 25;
            const dotRadius = 5;

            let lines = [];
            let boxes = [];
            let scores = { 'player1': 0, 'player2': 0 };
            let currentPlayer = 'player1';

            const playerColors = {
                'player1': { line: '#63b3ed', box: '#63b3ed80' },
                'player2': { line: '#f6ad55', box: '#f6ad5580' }
            };

            const switchTurn = (scored) => {
                if (!scored) {
                    currentPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
                    player1Card.classList.toggle('active', currentPlayer === 'player1');
                    player2Card.classList.toggle('active', currentPlayer === 'player2');
                    statusEl.textContent = `Current Turn: ${currentPlayer === 'player1' ? 'Player 1' : 'Player 2'}`;
                }
            };

            const updateStatus = () => {
                score1El.textContent = scores['player1'];
                score2El.textContent = scores['player2'];

                if (boxes.length === boardSize * boardSize) {
                    let winnerText = "It's a tie!";
                    if (scores['player1'] > scores['player2']) {
                        winnerText = "Player 1 wins!";
                    } else if (scores['player2'] > scores['player1']) {
                        winnerText = "Player 2 wins!";
                    }
                    messageTitle.textContent = `Game Over! ${winnerText}`;
                    messageBox.style.display = 'block';
                }
            };

            const drawGrid = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineCap = 'round';
                ctx.lineWidth = 3;

                // Draw captured boxes
                boxes.forEach(box => {
                    ctx.fillStyle = box.color;
                    const x = padding + box.x * cellSize + dotRadius;
                    const y = padding + box.y * cellSize + dotRadius;
                    ctx.fillRect(x, y, cellSize - 2 * dotRadius, cellSize - 2 * dotRadius);
                });

                // Draw all lines
                lines.forEach(line => {
                    ctx.strokeStyle = line.color;
                    ctx.beginPath();
                    ctx.moveTo(padding + line.x1 * cellSize, padding + line.y1 * cellSize);
                    ctx.lineTo(padding + line.x2 * cellSize, padding + line.y2 * cellSize);
                    ctx.stroke();
                });

                // Draw dots on top
                ctx.fillStyle = '#cbd5e0';
                for (let i = 0; i < boardSize + 1; i++) {
                    for (let j = 0; j < boardSize + 1; j++) {
                        ctx.beginPath();
                        ctx.arc(padding + i * cellSize, padding + j * cellSize, dotRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            };

            const findLine = (x1, y1, x2, y2) => {
                if (x1 > x2 || y1 > y2) {
                    [x1, x2] = [x2, x1];
                    [y1, y2] = [y2, y1];
                }
                return lines.find(line => 
                    line.x1 === x1 && line.y1 === y1 && line.x2 === x2 && line.y2 === y2
                );
            };

            const checkForCompletedBox = (x, y, isVertical) => {
                let newBoxesCount = 0;
                let potentialBoxes = [];

                if (isVertical) {
                    potentialBoxes.push({ x: x - 1, y: y }); 
                    potentialBoxes.push({ x: x, y: y });
                } else {
                    potentialBoxes.push({ x: x, y: y - 1 }); 
                    potentialBoxes.push({ x: x, y: y });
                }
                
                potentialBoxes.forEach(box => {
                    if (box.x >= 0 && box.x < boardSize && box.y >= 0 && box.y < boardSize) {
                        const top = findLine(box.x, box.y, box.x + 1, box.y);
                        const right = findLine(box.x + 1, box.y, box.x + 1, box.y + 1);
                        const bottom = findLine(box.x, box.y + 1, box.x + 1, box.y + 1);
                        const left = findLine(box.x, box.y, box.x, box.y + 1);
                        
                        const isCompleted = [top, right, bottom, left].every(line => line !== undefined);
                        
                        if (isCompleted && !boxes.some(b => b.x === box.x && b.y === box.y)) {
                            boxes.push({ x: box.x, y: box.y, color: playerColors[currentPlayer].box });
                            newBoxesCount++;
                        }
                    }
                });
                return newBoxesCount;
            };

            const handleLineClick = (event) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                const gridX = Math.round((mouseX - padding) / cellSize);
                const gridY = Math.round((mouseY - padding) / cellSize);

                const dx = Math.abs(mouseX - (padding + gridX * cellSize));
                const dy = Math.abs(mouseY - (padding + gridY * cellSize));

                let x1, y1, x2, y2;
                let isVertical = false;

                if (dx < cellSize / 4 && dy > cellSize / 4) { // Vertical line
                    if (gridY >= 0 && gridY < boardSize && gridX >= 0 && gridX < boardSize + 1) {
                        x1 = x2 = gridX;
                        y1 = gridY;
                        y2 = gridY + 1;
                        isVertical = true;
                    } else { return; }
                } else if (dy < cellSize / 4 && dx > cellSize / 4) { // Horizontal line
                    if (gridX >= 0 && gridX < boardSize && gridY >= 0 && gridY < boardSize + 1) {
                        x1 = gridX;
                        x2 = gridX + 1;
                        y1 = y2 = gridY;
                        isVertical = false;
                    } else { return; }
                } else { return; }

                if (x1 > x2 || y1 > y2) {
                    [x1, x2] = [x2, x1];
                    [y1, y2] = [y2, y1];
                }

                if (findLine(x1, y1, x2, y2)) {
                    return; // Line already exists
                }

                lines.push({ x1, y1, x2, y2, color: playerColors[currentPlayer].line });
                const newBoxes = checkForCompletedBox(Math.min(x1, x2), Math.min(y1, y2), isVertical);
                scores[currentPlayer] += newBoxes;
                
                drawGrid();
                updateStatus();
                switchTurn(newBoxes > 0);
            };

            const initializeGame = () => {
                lines = [];
                boxes = [];
                scores = { 'player1': 0, 'player2': 0 };
                currentPlayer = 'player1';
                messageBox.style.display = 'none';
                canvas.width = (boardSize * cellSize) + (2 * padding);
                canvas.height = (boardSize * cellSize) + (2 * padding);
                player1Card.classList.add('active');
                player2Card.classList.remove('active');
                drawGrid();
                updateStatus();
                statusEl.textContent = `Current Turn: Player 1`;
            };

            canvas.addEventListener('click', handleLineClick);
            restartBtn.addEventListener('click', initializeGame);
            restartMessageBtn.addEventListener('click', initializeGame);

            initializeGame();
        });
    </script>
</body>
</html>
