<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dots and Boxes</title>
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Custom styles for a better look and feel */
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            background-color: #1a202c; /* Dark background */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #e2e8f0; /* Light text color */
            padding: 20px; /* Add some padding for smaller screens */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        .game-container {
            background-color: #2d3748; /* Slightly lighter dark background for the container */
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3); /* Deeper shadow */
            padding: 2.5rem; /* Increased padding */
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px; /* Max width for larger screens */
        }

        canvas {
            background-color: #4a5568; /* Canvas background */
            border-radius: 0.75rem; /* Rounded canvas corners */
            display: block;
            margin-bottom: 1.5rem;
            touch-action: none; /* Disable default touch actions like scrolling */
        }

        .status-area {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 1.5rem;
            font-size: 1.25rem;
            font-weight: bold;
            text-align: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .player-score {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            margin: 0.5rem;
        }

        .player-score.active {
            background-color: #4299e1; /* Blue for active player */
            color: #2d3748;
        }

        .player-score.player1-color {
            border: 2px solid #f56565; /* Red border for Player 1 */
        }

        .player-score.player2-color {
            border: 2px solid #63b3ed; /* Blue border for Player 2 */
        }

        .current-turn-message {
            margin-top: 1rem;
            font-size: 1.5rem;
            font-weight: bold;
            min-height: 2rem;
            text-align: center;
        }

        .button-group {
            display: flex;
            gap: 1rem; /* Space between buttons */
            margin-top: 2rem;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
            justify-content: center;
        }

        .game-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-out, box-shadow 0.2s ease-in-out;
            border: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        .game-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .game-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            transition: all 0.75s ease-out;
            transform: translate(-50%, -50%) scale(0);
            opacity: 0;
            z-index: 0;
        }

        .game-button:hover::before {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .game-button span {
            position: relative;
            z-index: 1;
        }

        /* Specific button styles */
        #resetButton {
            background-color: #ecc94b; /* Yellow */
            color: #2d3748;
        }

        #resetButton:hover {
            background-color: #d69e2e; /* Darker yellow */
        }

        /* Mode selection buttons */
        .mode-selection-button {
            background-color: #63b3ed; /* Blue */
            color: #2d3748;
        }
        .mode-selection-button:hover {
            background-color: #4299e1; /* Darker blue */
        }

        #startGameButton {
            background-color: #48bb78; /* Green */
            color: #2d3748;
        }
        #startGameButton:hover {
            background-color: #38a169; /* Darker green */
        }

        #signOutButton {
            background-color: #e53e3e; /* Red */
            color: #fff;
        }
        #signOutButton:hover {
            background-color: #c53030; /* Darker red */
        }

        /* Message box for alerts */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            border: 2px solid #4a5568;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            text-align: center;
            max-width: 90%;
            color: #e2e8f0;
        }

        .message-box-content {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
        }

        .message-box-button {
            background-color: #63b3ed;
            color: #2d3748;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border: none;
        }

        .message-box-button:hover {
            background-color: #4299e1;
        }

        /* Registration Form Styles */
        .registration-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
            max-width: 350px;
            margin-bottom: 2rem;
        }

        .registration-form input {
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 2px solid #4a5568;
            background-color: #2d3748;
            color: #e2e8f0;
            font-size: 1rem;
        }

        .registration-form input:focus {
            outline: none;
            border-color: #63b3ed;
        }

        .hidden {
            display: none !important;
        }

        /* Level selection buttons */
        .level-buttons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            max-height: 150px; /* Limit height for scrollability */
            overflow-y: auto; /* Enable vertical scrolling */
            padding: 0.5rem;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }

        .level-button {
            padding: 0.5rem 0.8rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            background-color: #4a5568; /* Default grey */
            color: #e2e8f0;
            border: 1px solid #636b7a;
            transition: background-color 0.2s ease-in-out;
        }

        .level-button:hover:not(.locked):not(.selected) {
            background-color: #636b7a;
        }

        .level-button.selected {
            background-color: #63b3ed; /* Selected level color */
            color: #2d3748;
            border-color: #63b3ed;
        }

        .level-button.locked {
            background-color: #3a424e; /* Darker grey for locked */
            color: #9ca3af; /* Faded text */
            cursor: not-allowed;
            opacity: 0.7;
            border-color: #3a424e;
        }

        #authScreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            width: 100%;
            max-width: 400px;
        }

        #authForm {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
        }
        #authForm input {
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 2px solid #4a5568;
            background-color: #2d3748;
            color: #e2e8f0;
            font-size: 1rem;
        }

        .online-users-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            padding: 0.5rem;
        }
        .online-user-button {
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: #4a5568;
            color: #e2e8f0;
            font-weight: bold;
            text-align: left;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .online-user-button:hover {
            background-color: #63b3ed;
            color: #2d3748;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="game-container">
        <h1 class="text-4xl md:text-5xl font-extrabold mb-6 text-yellow-400">Dots and Boxes</h1>

        <!-- Game Content -->
        <div id="gameContent" class="flex flex-col items-center w-full">

            <!-- Mode Selection Screen -->
            <div id="modeSelectionScreen" class="flex flex-col items-center gap-4">
                <h2 class="text-2xl font-bold text-center mb-2">Choose Game Mode</h2>
                <div class="button-group">
                    <button id="selectComputerModeButton" class="game-button mode-selection-button"><span>Play with Computer</span></button>
                    <button id="selectFriendModeButton" class="game-button mode-selection-button"><span>Play with a Friend</span></button>
                </div>
            </div>

            <!-- Registration Form (initially hidden) -->
            <div id="registrationScreen" class="registration-form hidden">
                <h2 class="text-2xl font-bold text-center mb-4" id="registrationTitle">Register Players</h2>
                <input type="text" id="player1NameInput" placeholder="Player 1 Name (Blue)" maxlength="10">
                <input type="text" id="player2NameInput" placeholder="Player 2 Name (Orange)" maxlength="10">
                
                <div id="levelSelectionArea" class="hidden">
                    <label for="gameLevelInput" class="text-sm text-gray-400 mb-2">Difficulty Level (1-100): <span id="currentUnlockedLevelDisplay">1</span></label>
                    <input type="hidden" id="gameLevelInput" value="1"> <!-- Hidden input to store selected level -->
                    <div id="levelButtonsContainer" class="level-buttons-container">
                        <!-- Level buttons will be generated here -->
                    </div>
                </div>

                <button id="startGameButton" class="game-button mt-4"><span>Start Game</span></button>
            </div>
            


            <!-- Game UI (initially hidden) -->
            <div id="gameUI" class="hidden flex flex-col items-center w-full">
                <div class="status-area">
                    <div id="player1Score" class="player-score player1-color"></div>
                    <div id="player2Score" class="player-score player2-color"></div>
                </div>
                <div id="currentTurn" class="current-turn-message"></div>

                <canvas id="gameCanvas"></canvas>

                <div class="button-group">
                    <button id="resetButton" class="game-button"><span>Reset Game</span></button>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Message Box for alerts, invites, etc. -->
    <div id="messageBox" class="message-box">
        <div id="messageBoxContent" class="message-box-content"></div>
        <div class="flex gap-4" id="messageBoxActions">
            <button id="messageBoxButton" class="message-box-button">OK</button>
        </div>
    </div>

    <script>

        // Canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game configuration (now dynamic)
        let GRID_COLS; // Number of dot columns
        let GRID_ROWS; // Number of dot rows
        const MIN_COLS = 5; // Minimum number of columns
        const MAX_COLS = 8; // Maximum number of columns
        const MIN_ROWS = 4; // Minimum number of rows
        const MAX_ROWS = 7; // Maximum number of rows

        const DOT_RADIUS = 8;
        const LINE_THICKNESS = 4;
        const DOT_COLOR = '#63b3ed'; // Blue dots
        const PLAYER1_LINE_COLOR = '#63b3ed'; // Blue lines for Player 1
        const PLAYER2_LINE_COLOR = '#ed8936'; // Orange lines for Player 2
        const BOX_FILL_COLOR_P1 = 'rgba(99, 179, 237, 0.2)'; // Light blue fill
        const BOX_FILL_COLOR_P2 = 'rgba(237, 137, 54, 0.2)'; // Light orange fill
        const HOVER_LINE_COLOR = 'rgba(255, 255, 255, 0.3)'; // Light grey for hover

        // Game state
        let dots = []; // Stores {x, y} coordinates of each dot
        let horizontalLines = []; // Stores state of horizontal lines (GRID_ROWS x (GRID_COLS-1) array)
        let verticalLines = [];   // Stores state of vertical lines ((GRID_ROWS-1) x GRID_COLS array)
        let boxes = [];           // Stores owner's name of each box ((GRID_ROWS-1) x (GRID_COLS-1) array)
        let playerScores = {};
        let currentPlayer = '';
        let isGameActive = true;
        let isVsComputer = false; // Flag to indicate if playing against computer
        let gameLevel = 1; // Current game difficulty level selected
        let currentUnlockedLevel = 1; // Tracks the highest level unlocked by the player

        let player1Name = '';
        let player2Name = '';
        const COMPUTER_NAME = 'Computer';

        const modeSelectionScreen = document.getElementById('modeSelectionScreen');
        const selectComputerModeButton = document.getElementById('selectComputerModeButton');
        const selectFriendModeButton = document.getElementById('selectFriendModeButton');

        const registrationScreen = document.getElementById('registrationScreen');
        const registrationTitle = document.getElementById('registrationTitle');
        const player1NameInput = document.getElementById('player1NameInput');
        const player2NameInput = document.getElementById('player2NameInput');
        const levelSelectionArea = document.getElementById('levelSelectionArea');
        const gameLevelInput = document.getElementById('gameLevelInput');
        const currentUnlockedLevelDisplay = document.getElementById('currentUnlockedLevelDisplay');
        const levelButtonsContainer = document.getElementById('levelButtonsContainer');
        const startGameButton = document.getElementById('startGameButton');
        


        const gameUI = document.getElementById('gameUI');
        const player1ScoreDisplay = document.getElementById('player1Score');
        const player2ScoreDisplay = document.getElementById('player2Score');
        const currentTurnDisplay = document.getElementById('currentTurn');
        const resetButton = document.getElementById('resetButton');

        const messageBox = document.getElementById('messageBox');
        const messageBoxContent = document.getElementById('messageBoxContent');
        const messageBoxButton = document.getElementById('messageBoxButton');
        const messageBoxActions = document.getElementById('messageBoxActions');



        // Canvas dimensions (will be set dynamically)
        let cellSize;
        let offsetX, offsetY; // Offset to center the grid on the canvas

        /**
         * Displays a custom message box with a single OK button.
         * @param {string} message - The message to display.
         */
        function showMessageBox(message) {
            messageBoxContent.textContent = message;
            messageBoxActions.innerHTML = `<button id="messageBoxButton" class="message-box-button">OK</button>`;
            document.getElementById('messageBoxButton').addEventListener('click', hideMessageBox, { once: true });
            messageBox.style.display = 'flex';
        }

        /**
         * Displays a custom message box with Accept/Decline buttons.
         * @param {string} message - The message to display.
         * @param {function} onAccept - Callback for the accept button.
         * @param {function} onDecline - Callback for the decline button.
         */
        function showInvitationBox(message, onAccept, onDecline) {
            messageBoxContent.textContent = message;
            messageBoxActions.innerHTML = `
                <button id="acceptButton" class="game-button bg-green-500 hover:bg-green-600"><span>Accept</span></button>
                <button id="declineButton" class="game-button bg-red-500 hover:bg-red-600"><span>Decline</span></button>
            `;
            document.getElementById('acceptButton').addEventListener('click', onAccept, { once: true });
            document.getElementById('declineButton').addEventListener('click', onDecline, { once: true });
            messageBox.style.display = 'flex';
        }

        /**
         * Hides the custom message box.
         */
        function hideMessageBox() {
            messageBox.style.display = 'none';
        }

        /**
         * Generates random grid dimensions for a new game.
         */
        function generateRandomGridDimensions() {
            GRID_COLS = Math.floor(Math.random() * (MAX_COLS - MIN_COLS + 1)) + MIN_COLS;
            GRID_ROWS = Math.floor(Math.random() * (MAX_ROWS - MIN_ROWS + 1)) + MIN_ROWS;
            console.log(`New game grid: ${GRID_COLS} columns x ${GRID_ROWS} rows`);
        }


        

        

        

        

        

        
        /**
         * Generates and updates the level selection buttons.
         */
        function generateLevelButtons() {
            levelButtonsContainer.innerHTML = ''; // Clear existing buttons
            for (let i = 1; i <= 100; i++) {
                const levelButton = document.createElement('button');
                levelButton.classList.add('level-button');
                levelButton.textContent = i;
                levelButton.dataset.level = i;

                if (i > currentUnlockedLevel) {
                    levelButton.classList.add('locked');
                    levelButton.disabled = true;
                } else {
                    levelButton.addEventListener('click', () => {
                        // Deselect all other level buttons
                        document.querySelectorAll('.level-button').forEach(btn => btn.classList.remove('selected'));
                        // Select this one
                        levelButton.classList.add('selected');
                        gameLevelInput.value = i; // Update hidden input
                    });
                }
                levelButtonsContainer.appendChild(levelButton);
            }
            // Automatically select the highest unlocked level when buttons are generated
            const defaultSelectedButton = document.querySelector(`.level-button[data-level="${currentUnlockedLevel}"]`);
            if (defaultSelectedButton) {
                defaultSelectedButton.classList.add('selected');
                gameLevelInput.value = currentUnlockedLevel;
            }
            currentUnlockedLevelDisplay.textContent = currentUnlockedLevel;
        }

        /**
         * Handles selecting the "Play with Computer" mode.
         */
        function selectComputerMode() {
            isVsComputer = true;
            isOnlineMultiplayer = false;
            player2NameInput.value = COMPUTER_NAME;
            player2NameInput.disabled = true;
            levelSelectionArea.classList.remove('hidden');
            registrationTitle.textContent = 'Play with Computer';
            generateLevelButtons(); // Generate level buttons for computer mode
            modeSelectionScreen.classList.add('hidden');
            registrationScreen.classList.remove('hidden');
        }

        /**
         * Handles selecting the "2 Players" mode.
         */
        function selectFriendMode() {
            isVsComputer = false;
            isOnlineMultiplayer = false;
            player2NameInput.value = '';
            player2NameInput.disabled = false;
            levelSelectionArea.classList.add('hidden'); // Hide level selection
            registrationTitle.textContent = '2 Players';
            modeSelectionScreen.classList.add('hidden');
            registrationScreen.classList.remove('hidden');
        }




        /**
         * Handles the start game button click and registers player names.
         */
        function handleStartGame() {
            const p1Name = player1NameInput.value.trim();
            const p2Name = player2NameInput.value.trim();
            const selectedLevel = parseInt(gameLevelInput.value);

            if (p1Name === '' || p2Name === '') {
                showMessageBox('Please enter names for both players.');
                return;
            }
            if (p1Name === p2Name) {
                showMessageBox('Player names cannot be identical.');
                return;
            }
            if (isVsComputer) {
                if (isNaN(selectedLevel) || selectedLevel < 1 || selectedLevel > currentUnlockedLevel) {
                    showMessageBox(`Please select a difficulty level between 1 and ${currentUnlockedLevel}.`);
                    return;
                }
                gameLevel = selectedLevel; // Set the game level based on user selection
            } else {
                gameLevel = 1; // Default to level 1 for 2-player mode (AI level is irrelevant)
            }
            player1Name = p1Name;
            player2Name = p2Name;
            registrationScreen.classList.add('hidden');
            gameUI.classList.remove('hidden');
            generateRandomGridDimensions(); // Generate new dimensions for the game
            initializeGame();
        }

        /**
         * Initializes the game board and state.
         */
        function initializeGame() {
            const containerWidth = canvas.parentElement.clientWidth - (2.5 * 16 * 2);
            const maxCanvasWidth = Math.min(containerWidth, 500);
            const idealCellSize = (maxCanvasWidth - (2 * DOT_RADIUS)) / (GRID_COLS - 1);
            canvas.width = (GRID_COLS - 1) * idealCellSize + (2 * DOT_RADIUS);
            canvas.height = (GRID_ROWS - 1) * idealCellSize + (2 * DOT_RADIUS);
            cellSize = idealCellSize;
            offsetX = DOT_RADIUS;
            offsetY = DOT_RADIUS;

            dots = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    dots.push({ x: offsetX + c * cellSize, y: offsetY + r * cellSize });
                }
            }

            horizontalLines = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS - 1).fill(null));
            verticalLines = Array(GRID_ROWS - 1).fill(null).map(() => Array(GRID_COLS).fill(null));
            boxes = Array(GRID_ROWS - 1).fill(null).map(() => Array(GRID_COLS - 1).fill(null));
            playerScores = {};
            playerScores[player1Name] = 0;
            playerScores[player2Name] = 0;
            currentPlayer = player1Name;
            isGameActive = true;
            
            updateStatusDisplay();
            drawGame();

            if (isVsComputer && currentPlayer === COMPUTER_NAME) {
                setTimeout(computerMove, 500);
            }
        }
        


        /**
         * Draws the entire game state on the canvas.
         */
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw completed boxes and their owner's first letter
            for (let r = 0; r < GRID_ROWS - 1; r++) {
                for (let c = 0; c < GRID_COLS - 1; c++) {
                    const owner = boxes[r][c];
                    if (owner) {
                        const boxX = offsetX + c * cellSize + LINE_THICKNESS / 2;
                        const boxY = offsetY + r * cellSize + LINE_THICKNESS / 2;
                        const boxSize = cellSize - LINE_THICKNESS;

                        // Draw box background fill
                        ctx.fillStyle = (owner === player1Name) ? BOX_FILL_COLOR_P1 : BOX_FILL_COLOR_P2;
                        ctx.fillRect(boxX, boxY, boxSize, boxSize);

                        // Draw first letter of owner's name
                        ctx.fillStyle = '#e2e8f0'; // White text color
                        ctx.font = `${boxSize * 0.6}px 'Inter', sans-serif`; // Adjust font size
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(owner.charAt(0).toUpperCase(), boxX + boxSize / 2, boxY + boxSize / 2);
                    }
                }
            }

            // Draw existing lines
            ctx.lineWidth = LINE_THICKNESS;
            ctx.lineCap = 'round';

            // Horizontal lines
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS - 1; c++) {
                    if (horizontalLines[r][c]) {
                        ctx.strokeStyle = horizontalLines[r][c] === player1Name ? PLAYER1_LINE_COLOR : PLAYER2_LINE_COLOR;
                        ctx.beginPath();
                        ctx.moveTo(dots[r * GRID_COLS + c].x, dots[r * GRID_COLS + c].y);
                        ctx.lineTo(dots[r * GRID_COLS + c + 1].x, dots[r * GRID_COLS + c + 1].y);
                        ctx.stroke();
                    }
                }
            }

            // Vertical lines
            for (let r = 0; r < GRID_ROWS - 1; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (verticalLines[r][c]) {
                        ctx.strokeStyle = verticalLines[r][c] === player1Name ? PLAYER1_LINE_COLOR : PLAYER2_LINE_COLOR;
                        ctx.beginPath();
                        ctx.moveTo(dots[r * GRID_COLS + c].x, dots[r * GRID_COLS + c].y);
                        ctx.lineTo(dots[(r + 1) * GRID_COLS + c].x, dots[(r + 1) * GRID_COLS + c].y);
                        ctx.stroke();
                    }
                }
            }

            // Draw dots on top
            ctx.fillStyle = DOT_COLOR;
            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, DOT_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        /**
         * Updates the score and current turn displays.
         */
        function updateStatusDisplay() {
            player1ScoreDisplay.textContent = `${player1Name}: ${playerScores[player1Name]}`;
            player2ScoreDisplay.textContent = `${player2Name}: ${playerScores[player2Name]}`;
            player1ScoreDisplay.classList.toggle('active', currentPlayer === player1Name);
            player2ScoreDisplay.classList.toggle('active', currentPlayer === player2Name);
            currentTurnDisplay.textContent = isGameActive ? `${currentPlayer}'s turn` : '';
        }

        /**
         * Handles mouse/touch movement to show potential lines.
         * @param {Event} event - The mouse or touch event.
         */
        function handleMouseMove(event) {
            if (!isGameActive || (isOnlineMultiplayer && currentPlayer !== userName)) return;
            drawGame();

            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;

            const [lineType, index1, index2] = findNearestLine(mouseX, mouseY);

            if (lineType && (lineType === 'h' && !horizontalLines[index1][index2]) ||
                (lineType === 'v' && !verticalLines[index1][index2])) {
                drawHoverLine(lineType, index1, index2);
            }
        }

        /**
         * Draws a line to indicate hover state.
         * @param {string} type - 'h' for horizontal, 'v' for vertical.
         * @param {number} r - Row index.
         * @param {number} c - Column index.
         */
        function drawHoverLine(type, r, c) {
            ctx.strokeStyle = HOVER_LINE_COLOR;
            ctx.lineWidth = LINE_THICKNESS;
            ctx.beginPath();
            if (type === 'h') {
                const dot1 = dots[r * GRID_COLS + c];
                const dot2 = dots[r * GRID_COLS + c + 1];
                ctx.moveTo(dot1.x, dot1.y);
                ctx.lineTo(dot2.x, dot2.y);
            } else { // 'v'
                const dot1 = dots[r * GRID_COLS + c];
                const dot2 = dots[(r + 1) * GRID_COLS + c];
                ctx.moveTo(dot1.x, dot1.y);
                ctx.lineTo(dot2.x, dot2.y);
            }
            ctx.stroke();
        }

        /**
         * Finds the nearest line to the mouse coordinates.
         * @param {number} mouseX - The x-coordinate of the mouse.
         * @param {number} mouseY - The y-coordinate of the mouse.
         * @returns {Array} An array containing the line type ('h' or 'v'), row index, and column index.
         */
        function findNearestLine(mouseX, mouseY) {
            const snapThreshold = cellSize / 4; // Tolerance for snapping to a line

            // Check for horizontal lines
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS - 1; c++) {
                    const dot1 = dots[r * GRID_COLS + c];
                    const dot2 = dots[r * GRID_COLS + c + 1];
                    const lineY = dot1.y;
                    const lineX1 = dot1.x;
                    const lineX2 = dot2.x;

                    if (Math.abs(mouseY - lineY) < snapThreshold && mouseX > lineX1 && mouseX < lineX2) {
                        return ['h', r, c];
                    }
                }
            }

            // Check for vertical lines
            for (let r = 0; r < GRID_ROWS - 1; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const dot1 = dots[r * GRID_COLS + c];
                    const dot2 = dots[(r + 1) * GRID_COLS + c];
                    const lineX = dot1.x;
                    const lineY1 = dot1.y;
                    const lineY2 = dot2.y;

                    if (Math.abs(mouseX - lineX) < snapThreshold && mouseY > lineY1 && mouseY < lineY2) {
                        return ['v', r, c];
                    }
                }
            }

            return [null, null, null];
        }

        /**
         * Handles a mouse or touch click on the canvas.
         * @param {Event} event - The mouse or touch event.
         */
        function handleClick(event) {
            if (!isGameActive) return;
            if (isOnlineMultiplayer && currentPlayer !== userName) {
                 showMessageBox("It is not your turn!");
                 return;
            }

            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;

            const [lineType, r, c] = findNearestLine(mouseX, mouseY);

            if (lineType) {
                if (lineType === 'h' && !horizontalLines[r][c]) {
                    claimLine('h', r, c);
                } else if (lineType === 'v' && !verticalLines[r][c]) {
                    claimLine('v', r, c);
                }
            }
        }

        /**
         * Claims a line and checks for completed boxes.
         * @param {string} type - 'h' or 'v'.
         * @param {number} r - Row index.
         * @param {number} c - Column index.
         */
        function claimLine(type, r, c) {
            let boxesCompleted = false;
            let currentTurnPlayer = currentPlayer;

            if (type === 'h') {
                horizontalLines[r][c] = currentTurnPlayer;

                if (r > 0) {
                    if (horizontalLines[r - 1][c] && verticalLines[r - 1][c] && verticalLines[r - 1][c + 1]) {
                        boxes[r - 1][c] = currentTurnPlayer;
                        playerScores[currentTurnPlayer]++;
                        boxesCompleted = true;
                    }
                }
                if (r < GRID_ROWS - 1) {
                    if (horizontalLines[r + 1][c] && verticalLines[r][c] && verticalLines[r][c + 1]) {
                        boxes[r][c] = currentTurnPlayer;
                        playerScores[currentTurnPlayer]++;
                        boxesCompleted = true;
                    }
                }
            } else { // type === 'v'
                verticalLines[r][c] = currentTurnPlayer;

                if (c > 0) {
                    if (verticalLines[r][c - 1] && horizontalLines[r][c - 1] && horizontalLines[r + 1][c - 1]) {
                        boxes[r][c - 1] = currentTurnPlayer;
                        playerScores[currentTurnPlayer]++;
                        boxesCompleted = true;
                    }
                }
                if (c < GRID_COLS - 1) {
                    if (verticalLines[r][c + 1] && horizontalLines[r][c] && horizontalLines[r + 1][c]) {
                        boxes[r][c] = currentTurnPlayer;
                        playerScores[currentTurnPlayer]++;
                        boxesCompleted = true;
                    }
                }
            }

            let nextPlayer = currentTurnPlayer;
            if (!boxesCompleted) {
                nextPlayer = (currentTurnPlayer === player1Name) ? player2Name : player1Name;
            }

            currentPlayer = nextPlayer;
            isGameActive = !isGameOver();

            drawGame();
            updateStatusDisplay();

            if (!isGameActive) {
                endGame();
            } else if (isVsComputer && currentPlayer === COMPUTER_NAME) {
                setTimeout(computerMove, 500);
            }
        }


        /**
         * Checks if the game is over.
         * @returns {boolean} True if all boxes are filled, false otherwise.
         */
        function isGameOver() {
            return boxes.every(row => row.every(box => box !== null));
        }

        /**
         * Ends the game and displays the winner.
         */
        function endGame() {
            isGameActive = false;
            let winnerMessage;
            if (playerScores[player1Name] > playerScores[player2Name]) {
                winnerMessage = `${player1Name} wins with ${playerScores[player1Name]} boxes!`;
                // If against computer and player won, check if new level should be unlocked
                if (isVsComputer && gameLevel === currentUnlockedLevel) {
                    currentUnlockedLevel++;
                }
            } else if (playerScores[player2Name] > playerScores[player1Name]) {
                winnerMessage = `${player2Name} wins with ${playerScores[player2Name]} boxes!`;
            } else {
                winnerMessage = "It's a draw!";
            }

            currentTurnDisplay.textContent = 'Game Over';
            showMessageBox(winnerMessage);
        }

        /**
         * Resets the game to the initial state.
         */
        function resetGame() {
            gameUI.classList.add('hidden');
            modeSelectionScreen.classList.remove('hidden');
            registrationScreen.classList.add('hidden');
            player1NameInput.value = '';
            player2NameInput.value = '';
            levelSelectionArea.classList.add('hidden');
        }

        /**
         * AI for the computer player.
         * The AI's strategy depends on the difficulty level.
         */
        function computerMove() {
            let lineToTake = null;

            // Strategy 1: Find a line that completes a box
            lineToTake = findLineToCompleteBox();
            if (lineToTake) {
                claimLine(lineToTake.type, lineToTake.r, lineToTake.c);
                return;
            }

            // Strategy 2: Find a line that doesn't set up the opponent to complete a box
            if (gameLevel > 1) { // Apply this strategy for levels above 1
                lineToTake = findSafeLine();
            }

            // Strategy 3: Take any available line
            if (!lineToTake) {
                lineToTake = findRandomLine();
            }

            if (lineToTake) {
                claimLine(lineToTake.type, lineToTake.r, lineToTake.c);
            }
        }

        /**
         * Finds a line that, if taken, completes a box.
         * @returns {object|null} The line coordinates or null if no such line exists.
         */
        function findLineToCompleteBox() {
            // Check horizontal lines
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS - 1; c++) {
                    if (!horizontalLines[r][c] && isLineCompletingBox('h', r, c)) {
                        return { type: 'h', r, c };
                    }
                }
            }
            // Check vertical lines
            for (let r = 0; r < GRID_ROWS - 1; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (!verticalLines[r][c] && isLineCompletingBox('v', r, c)) {
                        return { type: 'v', r, c };
                    }
                }
            }
            return null;
        }

        /**
         * Finds a line that doesn't create a box with three sides for the opponent.
         * @returns {object|null} The line coordinates or null.
         */
        function findSafeLine() {
            let safeLines = [];
            // Check all possible lines
            // Horizontal lines
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS - 1; c++) {
                    if (!horizontalLines[r][c]) {
                        if (!isLineCreatingThreeSidedBox('h', r, c)) {
                            safeLines.push({ type: 'h', r, c });
                        }
                    }
                }
            }
            // Vertical lines
            for (let r = 0; r < GRID_ROWS - 1; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (!verticalLines[r][c]) {
                        if (!isLineCreatingThreeSidedBox('v', r, c)) {
                            safeLines.push({ type: 'v', r, c });
                        }
                    }
                }
            }

            if (safeLines.length > 0) {
                // Return a random safe line
                const randomIndex = Math.floor(Math.random() * safeLines.length);
                return safeLines[randomIndex];
            }
            return null;
        }

        /**
         * Finds a random available line to claim.
         * @returns {object|null} The line coordinates or null if no lines are available.
         */
        function findRandomLine() {
            const availableLines = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS - 1; c++) {
                    if (!horizontalLines[r][c]) availableLines.push({ type: 'h', r, c });
                }
            }
            for (let r = 0; r < GRID_ROWS - 1; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (!verticalLines[r][c]) availableLines.push({ type: 'v', r, c });
                }
            }

            if (availableLines.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableLines.length);
                return availableLines[randomIndex];
            }
            return null;
        }

        /**
         * Checks if a line, if claimed, will create a three-sided box.
         * @param {string} type - 'h' or 'v'.
         * @param {number} r - Row index.
         * @param {number} c - Column index.
         * @returns {boolean} True if a three-sided box is created, false otherwise.
         */
        function isLineCreatingThreeSidedBox(type, r, c) {
            // This function is for the computer's turn, so we'll check if taking this line
            // would leave the opponent with an easy point.
            if (type === 'h') {
                let boxSides = 0;
                // Check box above
                if (r > 0) {
                    boxSides += (horizontalLines[r - 1][c] ? 1 : 0);
                    boxSides += (verticalLines[r - 1][c] ? 1 : 0);
                    boxSides += (verticalLines[r - 1][c + 1] ? 1 : 0);
                    if (boxSides === 2) return true;
                    boxSides = 0;
                }
                // Check box below
                if (r < GRID_ROWS - 1) {
                    boxSides += (horizontalLines[r + 1][c] ? 1 : 0);
                    boxSides += (verticalLines[r][c] ? 1 : 0);
                    boxSides += (verticalLines[r][c + 1] ? 1 : 0);
                    if (boxSides === 2) return true;
                }
            } else { // type === 'v'
                let boxSides = 0;
                // Check box to the left
                if (c > 0) {
                    boxSides += (verticalLines[r][c - 1] ? 1 : 0);
                    boxSides += (horizontalLines[r][c - 1] ? 1 : 0);
                    boxSides += (horizontalLines[r + 1][c - 1] ? 1 : 0);
                    if (boxSides === 2) return true;
                    boxSides = 0;
                }
                // Check box to the right
                if (c < GRID_COLS - 1) {
                    boxSides += (verticalLines[r][c + 1] ? 1 : 0);
                    boxSides += (horizontalLines[r][c] ? 1 : 0);
                    boxSides += (horizontalLines[r + 1][c] ? 1 : 0);
                    if (boxSides === 2) return true;
                }
            }
            return false;
        }

        /**
         * Checks if a line, if claimed, will complete a box.
         * @param {string} type - 'h' or 'v'.
         * @param {number} r - Row index.
         * @param {number} c - Column index.
         * @returns {boolean} True if the line completes a box, false otherwise.
         */
        function isLineCompletingBox(type, r, c) {
            if (type === 'h') {
                // Check box above
                if (r > 0 && horizontalLines[r - 1][c] && verticalLines[r - 1][c] && verticalLines[r - 1][c + 1]) {
                    return true;
                }
                // Check box below
                if (r < GRID_ROWS - 1 && horizontalLines[r + 1][c] && verticalLines[r][c] && verticalLines[r][c + 1]) {
                    return true;
                }
            } else { // type === 'v'
                // Check box to the left
                if (c > 0 && verticalLines[r][c - 1] && horizontalLines[r][c - 1] && horizontalLines[r + 1][c - 1]) {
                    return true;
                }
                // Check box to the right
                if (c < GRID_COLS - 1 && verticalLines[r][c + 1] && horizontalLines[r][c] && horizontalLines[r + 1][c]) {
                    return true;
                }
            }
            return false;
        }


        // --- Firebase Authentication and Firestore Logic ---
        
        // Check if Firebase is available





        // Event Listeners for game logic
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mousedown', handleClick);
        canvas.addEventListener('touchmove', handleMouseMove);
        canvas.addEventListener('touchstart', handleClick);

        selectComputerModeButton.addEventListener('click', selectComputerMode);
        selectFriendModeButton.addEventListener('click', selectFriendMode);
        startGameButton.addEventListener('click', handleStartGame);
        resetButton.addEventListener('click', resetGame);

        // Add event listener for message box button
        document.addEventListener('click', (e) => {
            if (e.target.id === 'messageBoxButton') {
                hideMessageBox();
            }
        });

        window.addEventListener('resize', () => {
            if (!gameUI.classList.contains('hidden')) {
                initializeGame();
            }
        });

        // Initialize the game to show mode selection
        modeSelectionScreen.classList.remove('hidden');
    </script>
</body>
</html>
