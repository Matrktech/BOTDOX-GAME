<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dots and Boxes</title>
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Using CSS variables for dynamic theming. These are set by JavaScript. */
        :root {
            --body-bg-color: #1a202c;
            --container-bg-color: rgba(45, 55, 72, 0.85);
            --text-color: #e2e8f0;
            --text-color-dark: #1e293b;
            --heading-color: #ecc94b;
            --border-color: rgba(255, 255, 255, 0.1);
            --input-bg-color: #2d3748;
            --input-border-color: #4a5568;

            --player1-color: #f56565;
            --player2-color: #63b3ed;

            --accent-color-1: #48bb78;
            --accent-color-2: #ecc94b;
            --accent-color-3: #ef4444;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--body-bg-color);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: background-color 1s ease-in-out, background-image 1s ease-in-out;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: var(--text-color);
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrollbar during splash screen */
        }

        .game-container {
            background-color: var(--container-bg-color);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            padding: 2.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
            border: 1px solid var(--border-color);
            transition: background-color 0.5s ease;
        }

        canvas {
            background-color: var(--input-bg-color);
            border-radius: 0.75rem;
            display: block;
            margin-bottom: 1.5rem;
            touch-action: none;
            transition: background-color 0.5s ease;
        }

        .status-area {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 1.5rem;
            font-size: 1.25rem;
            font-weight: bold;
            text-align: center;
            flex-wrap: wrap;
        }

        .player-score {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            margin: 0.5rem;
            transition: all 0.3s ease-in-out;
            border-width: 2px;
            border-style: solid;
        }

        .player-score.active {
            transform: scale(1.1);
            color: var(--text-color-dark);
            box-shadow: 0 0 15px var(--active-glow-color);
            background-color: var(--active-glow-color);
        }

        .player-score.player1-color {
            border-color: var(--player1-color);
        }

        .player-score.player2-color {
            border-color: var(--player2-color);
        }

        .current-turn-message {
            margin-top: 1rem;
            font-size: 1.5rem;
            font-weight: bold;
            min-height: 2rem;
            text-align: center;
            color: var(--text-color);
        }

        .button-group {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .game-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-out, box-shadow 0.2s ease-in-out;
            border: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            color: white;
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        #startGameButton { background-color: var(--accent-color-1); }
        .mode-selection-button { background-color: var(--accent-color-1); }
        #resetButton { background-color: var(--accent-color-2); }
        #signOutButton { background-color: var(--accent-color-3); }

        .message-box {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: var(--container-bg-color);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            border-radius: 1rem;
            padding: 2rem; box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5); z-index: 1000;
            display: none; flex-direction: column; align-items: center; text-align: center;
            max-width: 90%;
        }
        .message-box-content { font-size: 1.25rem; margin-bottom: 1.5rem; }
        .message-box-button {
            background-color: var(--accent-color-1); color: white; padding: 0.75rem 1.5rem;
            border-radius: 0.75rem; font-size: 1rem; font-weight: bold; cursor: pointer;
            transition: background-color 0.2s ease-in-out; border: none;
        }

        .registration-form input {
            padding: 0.75rem; border-radius: 0.5rem;
            border: 2px solid var(--input-border-color);
            background-color: var(--input-bg-color);
            color: var(--text-color);
            font-size: 1rem;
        }
        .registration-form input:focus {
            outline: none;
            border-color: var(--player1-color);
        }

        .hidden { display: none !important; }

        /* Splash Screen Styles */
        #splashScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--body-bg-color); /* Matches body background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 1;
            visibility: visible;
            transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
            flex-direction: column;
        }

        #splashScreen.fade-out {
            opacity: 0;
            visibility: hidden;
        }

        .splash-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 80%;
            max-height: 80%;
        }

        .splash-image {
            max-width: 100%;
            max-height: 100%;
            border-radius: 1rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            object-fit: contain; /* Ensure image scales within bounds without cropping */
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.7s ease-out, transform 0.7s ease-out;
            margin-bottom: 20px; /* Space between images if multiple visible */
        }

        .splash-image.active {
            opacity: 1;
            transform: translateY(0);
        }

        .splash-title {
            color: var(--heading-color);
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-top: 1rem;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.7s ease-out, transform 0.7s ease-out;
        }

        .splash-title.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* Fixed corner image */
        .corner-image {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 260px;
            height: auto;
            z-index: 1500; /* Above most UI, below splash (2000) */
            opacity: 0.9;
            pointer-events: none; /* Don't block clicks */
        }

        @media (max-width: 640px) {
            .corner-image { width: 180px; }
        }

        /* Splash gradient background */
        #splashScreen {
            background: linear-gradient(-45deg, #ff9a9e, #fad0c4, #a1c4fd, #c2e9fb);
            background-size: 400% 400%;
            animation: splashGradientShift 12s ease infinite;
        }

        @keyframes splashGradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Animated game background (used while playing) */
        .animated-game-bg {
            background-size: 400% 400%;
            animation: gameGradientShift 16s ease infinite;
        }
        @keyframes gameGradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

    </style>
</head>
<body>

    <!-- Splash Screen -->
    <div id="splashScreen">
        <div class="splash-content">
            <h1 id="splashTitle" class="splash-title">Dots and Boxes</h1>
            <img id="splashImage1" class="splash-image hidden" src="bots.png" alt="Game Screenshot 1">
            <img id="splashImage2" class="splash-image hidden" src="Picture1-removebg-preview (1).png" alt="Game Logo">
            <img id="splashImage3" class="splash-image hidden" src="MGC (2).png" alt="Player Image">
        </div>
    </div>

    <div class="game-container hidden">
        <h1 class="text-4xl md:text-5xl font-extrabold mb-6" style="color: var(--heading-color);">Dots and Boxes</h1>

        <div id="gameContent" class="flex flex-col items-center w-full">
            <div id="modeSelectionScreen" class="flex flex-col items-center gap-4">
                <h2 class="text-2xl font-bold text-center mb-2">Choose Game Mode</h2>
                <div class="button-group">
                    <button id="selectComputerModeButton" class="game-button mode-selection-button"><span>Play with Computer</span></button>
                    <button id="selectFriendModeButton" class="game-button mode-selection-button"><span>Play with a Friend</span></button>
                </div>
            </div>

            <div id="registrationScreen" class="registration-form hidden">
                <h2 class="text-2xl font-bold text-center mb-4" id="registrationTitle"></h2>
                <input type="text" id="player1NameInput" placeholder="Player 1 Name" maxlength="10">
                <input type="text" id="player2NameInput" placeholder="Player 2 Name" maxlength="10">
                <div id="levelSelectionArea" class="hidden">
                    <label for="gameLevelInput" class="text-sm text-gray-400 mb-2">Difficulty Level: <span id="currentUnlockedLevelDisplay">1</span></label>
                    <input type="hidden" id="gameLevelInput" value="1">
                    <div id="levelButtonsContainer" class="level-buttons-container"></div>
                </div>
                <button id="startGameButton" class="game-button mt-4"><span>Start Game</span></button>
            </div>

            <div id="gameUI" class="hidden flex flex-col items-center w-full">
                <div class="status-area">
                    <div id="player1Score" class="player-score player1-color"></div>
                    <div id="player2Score" class="player-score player2-color"></div>
                </div>
                <div id="currentTurn" class="current-turn-message"></div>
                <canvas id="gameCanvas"></canvas>
                <div class="button-group">
                    <button id="resetButton" class="game-button"><span>New Game</span></button>
                </div>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <div id="messageBoxContent" class="message-box-content"></div>
        <div class="flex gap-4" id="messageBoxActions">
            <button id="messageBoxButton" class="message-box-button">OK</button>
        </div>
    </div>

    <!-- Corner mascot image -->
    <img src="catoon.png" alt="Corner mascot" class="corner-image" />

    <script>
        // --- DYNAMIC COLOR PALETTES ---
        const palettes = [
            { // Sunset Orange & Pink
                player1: '#ff6b6b', player2: '#ffa07a', heading: '#ffd166', bodyBg: '#2d3436',
                containerBg: 'rgba(0, 0, 0, 0.2)', textColor: '#dfe6e9', textColorDark: '#2d3436',
                inputBg: '#636e72', inputBorder: '#b2bec3', accent1: '#ff7675', accent2: '#fdcb6e', accent3: '#e17055',
                dotColor: '#ffeaa7', hover: 'rgba(253, 203, 110, 0.5)'
            },
            { // Electric Vibe
                player1: '#f85aff', player2: '#4bfffb', heading: '#a2ff86', bodyBg: '#1e272e',
                containerBg: 'rgba(44, 44, 84, 0.5)', textColor: '#d2dae2', textColorDark: '#1e272e',
                inputBg: '#485460', inputBorder: '#808e9b', accent1: '#00d2d3', accent2: '#ff9f43', accent3: '#ee5253',
                dotColor: '#54a0ff', hover: 'rgba(255, 255, 255, 0.4)'
            },
            { // Pastel Dream
                player1: '#ff9a9e', player2: '#fecfef', heading: '#a1c4fd', bodyBg: '#e0c3fc',
                containerBg: 'rgba(255, 255, 255, 0.4)', textColor: '#66545e', textColorDark: '#ffffff',
                inputBg: '#f6e6ff', inputBorder: '#d4b2ff', accent1: '#a1c4fd', accent2: '#ffdde1', accent3: '#fad0c4',
                dotColor: '#a1c4fd', hover: 'rgba(94, 100, 120, 0.4)'
            },
            { // Forest & Fire
                player1: '#ff7e5f', player2: '#feb47b', heading: '#b7e9de', bodyBg: '#0f2027',
                containerBg: 'rgba(32, 48, 55, 0.7)', textColor: '#c9d6ff', textColorDark: '#0f2027',
                inputBg: '#2c5364', inputBorder: '#527785', accent1: '#6a9113', accent2: '#e94057', accent3: '#f27121',
                dotColor: '#feb47b', hover: 'rgba(254, 180, 123, 0.5)'
            },
            { // Ocean Breeze
                player1: '#00c9ff', player2: '#92fe9d', heading: '#fef9d7', bodyBg: '#07163c',
                containerBg: 'rgba(18, 44, 82, 0.6)', textColor: '#eef2f3', textColorDark: '#07163c',
                inputBg: '#203A43', inputBorder: '#43a1b1', accent1: '#00c9ff', accent2: '#f5af19', accent3: '#e53935',
                dotColor: '#92fe9d', hover: 'rgba(146, 254, 157, 0.6)'
            }
        ];
        let currentPalette;

        // Animated gradients to use during gameplay
        const gameBackgroundGradients = [
            'linear-gradient(-45deg, #ff9a9e, #fad0c4, #a1c4fd, #c2e9fb)',
            'linear-gradient(45deg, #ffecd2, #fcb69f, #ff9a9e, #fecfef)',
            'linear-gradient(-45deg, #a1ffce, #faffd1, #cfd9df, #e2ebf0)',
            'linear-gradient(45deg, #f6d365, #fda085, #fbc2eb, #a6c1ee)',
            'linear-gradient(-45deg, #84fab0, #8fd3f4, #a1c4fd, #c2e9fb)',
            'linear-gradient(45deg, #ffdee9, #b5fffc, #fbe7c6, #c6f6d5)'
        ];

        function applyRandomGameGradient() {
            const gradient = gameBackgroundGradients[Math.floor(Math.random() * gameBackgroundGradients.length)];
            document.body.style.backgroundImage = gradient;
            document.body.classList.add('animated-game-bg');
        }

        function hexToRgba(hex, alpha) {
            let r = parseInt(hex.slice(1, 3), 16),
                g = parseInt(hex.slice(3, 5), 16),
                b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function applyPalette() {
            const rootStyle = document.documentElement.style;
            rootStyle.setProperty('--player1-color', currentPalette.player1);
            rootStyle.setProperty('--player2-color', currentPalette.player2);
            rootStyle.setProperty('--heading-color', currentPalette.heading);
            rootStyle.setProperty('--body-bg-color', currentPalette.bodyBg);
            rootStyle.setProperty('--container-bg-color', currentPalette.containerBg);
            rootStyle.setProperty('--text-color', currentPalette.textColor);
            rootStyle.setProperty('--text-color-dark', currentPalette.textColorDark);
            rootStyle.setProperty('--input-bg-color', currentPalette.inputBg);
            rootStyle.setProperty('--input-border-color', currentPalette.inputBorder);
            rootStyle.setProperty('--accent-color-1', currentPalette.accent1);
            rootStyle.setProperty('--accent-color-2', currentPalette.accent2);
            rootStyle.setProperty('--accent-color-3', currentPalette.accent3);
            rootStyle.setProperty('--active-glow-color', currentPalette.heading);

            // Update JS canvas variables
            PLAYER1_LINE_COLOR = currentPalette.player1;
            PLAYER2_LINE_COLOR = currentPalette.player2;
            BOX_FILL_COLOR_P1 = hexToRgba(currentPalette.player1, 0.4);
            BOX_FILL_COLOR_P2 = hexToRgba(currentPalette.player2, 0.4);
            DOT_COLOR = currentPalette.dotColor;
            HOVER_LINE_COLOR = currentPalette.hover;
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game configuration
        let GRID_COLS, GRID_ROWS;
        const MIN_COLS = 5, MAX_COLS = 8, MIN_ROWS = 4, MAX_ROWS = 7;
        const DOT_RADIUS = 8, LINE_THICKNESS = 5;
        // These are now 'let' and will be set by applyPalette()
        let DOT_COLOR, PLAYER1_LINE_COLOR, PLAYER2_LINE_COLOR;
        let BOX_FILL_COLOR_P1, BOX_FILL_COLOR_P2;
        let HOVER_LINE_COLOR;

        // Game state and DOM Elements... (rest of the script is largely unchanged)
        let dots = [], horizontalLines = [], verticalLines = [], boxes = [];
        let playerScores = {}, currentPlayer = '', isGameActive = true, isVsComputer = false;
        let gameLevel = 1, currentUnlockedLevel = 1;
        let player1Name = '', player2Name = '', COMPUTER_NAME = 'Computer';

        const modeSelectionScreen = document.getElementById('modeSelectionScreen');
        const registrationScreen = document.getElementById('registrationScreen');
        const gameUI = document.getElementById('gameUI');
        const selectComputerModeButton = document.getElementById('selectComputerModeButton');
        const selectFriendModeButton = document.getElementById('selectFriendModeButton');
        const registrationTitle = document.getElementById('registrationTitle');
        const player1NameInput = document.getElementById('player1NameInput');
        const player2NameInput = document.getElementById('player2NameInput');
        const levelSelectionArea = document.getElementById('levelSelectionArea');
        const gameLevelInput = document.getElementById('gameLevelInput');
        const currentUnlockedLevelDisplay = document.getElementById('currentUnlockedLevelDisplay');
        const levelButtonsContainer = document.getElementById('levelButtonsContainer');
        const startGameButton = document.getElementById('startGameButton');
        const player1ScoreDisplay = document.getElementById('player1Score');
        const player2ScoreDisplay = document.getElementById('player2Score');
        const currentTurnDisplay = document.getElementById('currentTurn');
        const resetButton = document.getElementById('resetButton');
        const messageBox = document.getElementById('messageBox');
        const messageBoxContent = document.getElementById('messageBoxContent');
        const messageBoxActions = document.getElementById('messageBoxActions');
        let cellSize, offsetX, offsetY;

        // Splash screen elements
        const splashScreen = document.getElementById('splashScreen');
        const splashTitle = document.getElementById('splashTitle');
        const splashImages = [
            document.getElementById('splashImage1'),
            document.getElementById('splashImage2'),
            document.getElementById('splashImage3')
        ];
        let currentSplashImageIndex = 0;

        function handleStartGame() {
            const p1Name = player1NameInput.value.trim();
            const p2Name = player2NameInput.value.trim();

            if (p1Name === '' || p2Name === '') { return showMessageBox('Please enter names for both players.'); }
            if (p1Name === p2Name) { return showMessageBox('Player names cannot be identical.'); }

            // --- NEW: Select and apply a random palette for the new game ---
            currentPalette = palettes[Math.floor(Math.random() * palettes.length)];
            applyPalette();
            applyRandomGameGradient();

            if (isVsComputer) {
                const selectedLevel = parseInt(gameLevelInput.value);
                if (isNaN(selectedLevel) || selectedLevel < 1 || selectedLevel > currentUnlockedLevel) {
                    return showMessageBox(`Please select a difficulty level between 1 and ${currentUnlockedLevel}.`);
                }
                gameLevel = selectedLevel;
            } else {
                gameLevel = 1;
            }
            player1Name = p1Name;
            player2Name = p2Name;

            registrationScreen.classList.add('hidden');
            gameUI.classList.remove('hidden');

            generateRandomGridDimensions();
            initializeGame();
        }

        function showMessageBox(message) {
            messageBoxContent.textContent = message;
            messageBoxActions.innerHTML = `<button id="messageBoxButton" class="message-box-button">OK</button>`;
            document.getElementById('messageBoxButton').addEventListener('click', hideMessageBox, { once: true });
            messageBox.style.display = 'flex';
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
        }

        function generateRandomGridDimensions() {
            GRID_COLS = Math.floor(Math.random() * (MAX_COLS - MIN_COLS + 1)) + MIN_COLS;
            GRID_ROWS = Math.floor(Math.random() * (MAX_ROWS - MIN_ROWS + 1)) + MIN_ROWS;
        }

        function generateLevelButtons() { /* Unchanged */ }

        function selectComputerMode() {
            isVsComputer = true;
            player2NameInput.value = COMPUTER_NAME;
            player2NameInput.disabled = true;
            levelSelectionArea.classList.remove('hidden');
            registrationTitle.textContent = 'Play with Computer';
            generateLevelButtons();
            modeSelectionScreen.classList.add('hidden');
            registrationScreen.classList.remove('hidden');
        }

        function selectFriendMode() {
            isVsComputer = false;
            player2NameInput.value = '';
            player2NameInput.disabled = false;
            levelSelectionArea.classList.add('hidden');
            registrationTitle.textContent = '2 Players';
            modeSelectionScreen.classList.add('hidden');
            registrationScreen.classList.remove('hidden');
        }

        function initializeGame() {
            const containerWidth = canvas.parentElement.clientWidth;
            const maxCanvasWidth = Math.min(containerWidth, 500);
            cellSize = (maxCanvasWidth) / (GRID_COLS);
            canvas.width = (GRID_COLS - 1) * cellSize + (2 * DOT_RADIUS);
            canvas.height = (GRID_ROWS - 1) * cellSize + (2 * DOT_RADIUS);
            offsetX = DOT_RADIUS;
            offsetY = DOT_RADIUS;

            dots = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    dots.push({ x: offsetX + c * cellSize, y: offsetY + r * cellSize });
                }
            }

            horizontalLines = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS - 1).fill(null));
            verticalLines = Array(GRID_ROWS - 1).fill(null).map(() => Array(GRID_COLS).fill(null));
            boxes = Array(GRID_ROWS - 1).fill(null).map(() => Array(GRID_COLS - 1).fill(null));
            playerScores = { [player1Name]: 0, [player2Name]: 0 };
            currentPlayer = player1Name;
            isGameActive = true;
            
            updateStatusDisplay();
            drawGame();

            if (isVsComputer && currentPlayer === COMPUTER_NAME) {
                setTimeout(computerMove, 500);
            }
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw boxes
            for (let r = 0; r < GRID_ROWS - 1; r++) {
                for (let c = 0; c < GRID_COLS - 1; c++) {
                    if (boxes[r][c]) {
                        const boxX = offsetX + c * cellSize;
                        const boxY = offsetY + r * cellSize;
                        ctx.fillStyle = (boxes[r][c] === player1Name) ? BOX_FILL_COLOR_P1 : BOX_FILL_COLOR_P2;
                        ctx.fillRect(boxX, boxY, cellSize, cellSize);
                        ctx.fillStyle = currentPalette.textColor;
                        ctx.font = `${cellSize * 0.6}px 'Inter', sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(boxes[r][c].charAt(0).toUpperCase(), boxX + cellSize / 2, boxY + cellSize / 2);
                    }
                }
            }
            // Draw lines
            ctx.lineWidth = LINE_THICKNESS;
            ctx.lineCap = 'round';
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS - 1; c++) {
                    if (horizontalLines[r][c]) {
                        ctx.strokeStyle = horizontalLines[r][c] === player1Name ? PLAYER1_LINE_COLOR : PLAYER2_LINE_COLOR;
                        ctx.beginPath();
                        ctx.moveTo(dots[r * GRID_COLS + c].x, dots[r * GRID_COLS + c].y);
                        ctx.lineTo(dots[r * GRID_COLS + c + 1].x, dots[r * GRID_COLS + c + 1].y);
                        ctx.stroke();
                    }
                }
            }
            for (let r = 0; r < GRID_ROWS - 1; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (verticalLines[r][c]) {
                        ctx.strokeStyle = verticalLines[r][c] === player1Name ? PLAYER1_LINE_COLOR : PLAYER2_LINE_COLOR;
                        ctx.beginPath();
                        ctx.moveTo(dots[r * GRID_COLS + c].x, dots[r * GRID_COLS + c].y);
                        ctx.lineTo(dots[(r + 1) * GRID_COLS + c].x, dots[(r + 1) * GRID_COLS + c].y);
                        ctx.stroke();
                    }
                }
            }
            // Draw dots
            ctx.fillStyle = DOT_COLOR;
            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, DOT_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function updateStatusDisplay() {
            player1ScoreDisplay.textContent = `${player1Name}: ${playerScores[player1Name]}`;
            player2ScoreDisplay.textContent = `${player2Name}: ${playerScores[player2Name]}`;
            player1ScoreDisplay.classList.toggle('active', currentPlayer === player1Name);
            player2ScoreDisplay.classList.toggle('active', currentPlayer === player2Name);
            currentTurnDisplay.textContent = isGameActive ? `${currentPlayer}'s turn` : 'Game Over';
        }

        function handleMouseMove(event) {
            if (!isGameActive) return;
            drawGame(); // Redraw to clear previous hover
            const [lineType, r, c] = getLineFromEvent(event);
            if (lineType && (lineType === 'h' && !horizontalLines[r][c]) || (lineType === 'v' && !verticalLines[r][c])) {
                drawHoverLine(lineType, r, c);
            }
        }

        function drawHoverLine(type, r, c) {
            ctx.strokeStyle = HOVER_LINE_COLOR;
            ctx.lineWidth = LINE_THICKNESS;
            ctx.beginPath();
            if (type === 'h') {
                ctx.moveTo(dots[r * GRID_COLS + c].x, dots[r * GRID_COLS + c].y);
                ctx.lineTo(dots[r * GRID_COLS + c + 1].x, dots[r * GRID_COLS + c + 1].y);
            } else {
                ctx.moveTo(dots[r * GRID_COLS + c].x, dots[r * GRID_COLS + c].y);
                ctx.lineTo(dots[(r + 1) * GRID_COLS + c].x, dots[(r + 1) * GRID_COLS + c].y);
            }
            ctx.stroke();
        }

        function getLineFromEvent(event) {
            const rect = canvas.getBoundingClientRect();
            const x = (event.touches ? event.touches[0].clientX : event.clientX) - rect.left;
            const y = (event.touches ? event.touches[0].clientY : event.clientY) - rect.top;
            const snapThreshold = cellSize / 3;

            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS - 1; c++) {
                    const dot1 = dots[r * GRID_COLS + c];
                    if (Math.abs(y - dot1.y) < snapThreshold && x > dot1.x && x < dot1.x + cellSize) {
                        return ['h', r, c];
                    }
                }
            }
            for (let r = 0; r < GRID_ROWS - 1; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const dot1 = dots[r * GRID_COLS + c];
                    if (Math.abs(x - dot1.x) < snapThreshold && y > dot1.y && y < dot1.y + cellSize) {
                        return ['v', r, c];
                    }
                }
            }
            return [null, null, null];
        }

        function handleClick(event) {
            if (!isGameActive || (isVsComputer && currentPlayer === COMPUTER_NAME)) return;
            const [lineType, r, c] = getLineFromEvent(event);
            if (lineType && ((lineType === 'h' && !horizontalLines[r][c]) || (lineType === 'v' && !verticalLines[r][c]))) {
                claimLine(lineType, r, c);
            }
        }

        function claimLine(type, r, c) {
            let boxesCompleted = 0;
            const playerWhoMoved = currentPlayer;
            if (type === 'h') {
                horizontalLines[r][c] = playerWhoMoved;
                if (r > 0 && isBoxComplete(r - 1, c)) { boxes[r-1][c] = playerWhoMoved; boxesCompleted++; }
                if (r < GRID_ROWS - 1 && isBoxComplete(r, c)) { boxes[r][c] = playerWhoMoved; boxesCompleted++; }
            } else { // 'v'
                verticalLines[r][c] = playerWhoMoved;
                if (c > 0 && isBoxComplete(r, c - 1)) { boxes[r][c-1] = playerWhoMoved; boxesCompleted++; }
                if (c < GRID_COLS - 1 && isBoxComplete(r, c)) { boxes[r][c] = playerWhoMoved; boxesCompleted++; }
            }

            if (boxesCompleted > 0) {
                playerScores[playerWhoMoved] += boxesCompleted;
            } else {
                currentPlayer = (currentPlayer === player1Name) ? player2Name : player1Name;
            }

            if (isGameOver()) {
                isGameActive = false;
                endGame();
            } else {
                    updateStatusDisplay();
                if (isVsComputer && currentPlayer === COMPUTER_NAME) {
                    setTimeout(computerMove, 500);
                }
            }
            drawGame();
        }

        const isBoxComplete = (r, c) => horizontalLines[r][c] && horizontalLines[r + 1][c] && verticalLines[r][c] && verticalLines[r][c + 1];
        const isGameOver = () => playerScores[player1Name] + playerScores[player2Name] === (GRID_ROWS - 1) * (GRID_COLS - 1);

        function endGame() {
            isGameActive = false;
            let winnerMessage;
            if (playerScores[player1Name] > playerScores[player2Name]) {
                winnerMessage = `${player1Name} wins with ${playerScores[player1Name]} boxes!`;
                if (isVsComputer && player1Name !== COMPUTER_NAME && gameLevel === currentUnlockedLevel) {
                    currentUnlockedLevel++;
                }
            } else if (playerScores[player2Name] > playerScores[player1Name]) {
                winnerMessage = `${player2Name} wins!`;
            } else {
                winnerMessage = "It's a draw!";
            }
            updateStatusDisplay();
            showMessageBox(winnerMessage);
        }

        function resetGame() {
            gameUI.classList.add('hidden');
            modeSelectionScreen.classList.remove('hidden');
            player1NameInput.value = '';
            player2NameInput.value = '';
            // Clear animated background when returning to mode selection
            document.body.style.backgroundImage = '';
            document.body.classList.remove('animated-game-bg');
        }

        function computerMove() {
            let move = findLineToCompleteBox() || findSafeLine() || findRandomLine();
            if (move) {
                claimLine(move.type, move.r, move.c);
            }
        }
        function countSides(r, c) {
            let count = 0;
            if (horizontalLines[r][c]) count++;
            if (horizontalLines[r + 1][c]) count++;
            if (verticalLines[r][c]) count++;
            if (verticalLines[r][c+1]) count++;
            return count;
        }
        function findLineToCompleteBox() {
            for (let r = 0; r < GRID_ROWS-1; r++) for (let c = 0; c < GRID_COLS-1; c++) {
                if (countSides(r,c) === 3) {
                    if (!horizontalLines[r][c]) return {type:'h',r:r,c:c};
                    if (!horizontalLines[r+1][c]) return {type:'h',r:r+1,c:c};
                    if (!verticalLines[r][c]) return {type:'v',r:r,c:c};
                    if (!verticalLines[r][c+1]) return {type:'v',r:r,c:c+1};
                }
            }
            return null;
        }
        function findSafeLine() {
            let safeLines = [];
            for (let r=0; r<GRID_ROWS; r++) for (let c=0; c<GRID_COLS-1; c++) {
                if (!horizontalLines[r][c]) {
                    let isSafe = true;
                    if (r>0) { horizontalLines[r][c]='temp'; if(countSides(r-1,c)===3) isSafe=false; horizontalLines[r][c]=null; }
                    if (r<GRID_ROWS-1 && isSafe) { horizontalLines[r][c]='temp'; if(countSides(r,c)===3) isSafe=false; horizontalLines[r][c]=null; }
                    if (isSafe) safeLines.push({type:'h',r,c});
                }
            }
            // Similar logic for vertical lines
            for (let r=0; r<GRID_ROWS-1; r++) for (let c=0; c<GRID_COLS; c++) {
                if (!verticalLines[r][c]) {
                    let isSafe = true;
                    if (c>0) { verticalLines[r][c]='temp'; if(countSides(r,c-1)===3) isSafe=false; verticalLines[r][c]=null; }
                    if (c<GRID_COLS-1 && isSafe) { verticalLines[r][c]='temp'; if(countSides(r,c)===3) isSafe=false; verticalLines[r][c]=null; }
                    if (isSafe) safeLines.push({type:'v',r,c});
                }
            }
            if (safeLines.length > 0) return safeLines[Math.floor(Math.random()*safeLines.length)];
            return null;
        }
        function findRandomLine() {
            let available = [];
            for (let r=0; r<GRID_ROWS; r++) for (let c=0; c<GRID_COLS-1; c++) if(!horizontalLines[r][c]) available.push({type:'h',r,c});
            for (let r=0; r<GRID_ROWS-1; r++) for (let c=0; c<GRID_COLS; c++) if(!verticalLines[r][c]) available.push({type:'v',r,c});
            if(available.length > 0) return available[Math.floor(Math.random()*available.length)];
            return null;
        }

        // --- SPLASH SCREEN LOGIC ---
        function animateSplashScreen() {
            // Show title first
            splashTitle.classList.add('active');

            setTimeout(() => {
                splashTitle.classList.remove('active'); // Hide title after a brief moment
                showNextSplashImage(0); // Start image sequence
            }, 1500); // Title visible for 1.5 seconds
        }

        function showNextSplashImage(index) {
            if (index < splashImages.length) {
                const img = splashImages[index];
                img.classList.remove('hidden');
                setTimeout(() => {
                    img.classList.add('active'); // Fade in and slide up
                }, 50); // Small delay to allow 'hidden' removal to take effect

                setTimeout(() => {
                    img.classList.remove('active'); // Fade out
                    setTimeout(() => {
                        img.classList.add('hidden'); // Hide completely after fading out
                        showNextSplashImage(index + 1); // Show next image
                    }, 700); // Wait for fade out to complete (0.7s)
                }, 2500); // Image visible for 2.5 seconds (adjust as needed)
            } else {
                // All images shown, fade out splash screen and show game
                splashScreen.classList.add('fade-out');
                document.body.style.overflow = 'auto'; // Re-enable scrolling if content is larger than viewport
                setTimeout(() => {
                    splashScreen.classList.add('hidden');
                    document.querySelector('.game-container').classList.remove('hidden'); // Show the main game content
                }, 700); // Wait for splash screen fade out to complete
            }
        }


        // Event Listeners
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mousedown', handleClick);
        canvas.addEventListener('touchmove', handleMouseMove);
        canvas.addEventListener('touchstart', handleClick);
        selectComputerModeButton.addEventListener('click', selectComputerMode);
        selectFriendModeButton.addEventListener('click', selectFriendMode);
        startGameButton.addEventListener('click', handleStartGame);
        resetButton.addEventListener('click', resetGame);
        window.addEventListener('resize', () => { if (!gameUI.classList.contains('hidden')) initializeGame(); });

        // Initial setup on window load
        window.onload = function() {
            currentPalette = palettes[0];
            applyPalette();
            document.querySelector('.game-container').classList.add('hidden'); // Ensure game container is hidden initially
            animateSplashScreen(); // Start the splash screen animation
        };
    </script>
</body>
</html>
